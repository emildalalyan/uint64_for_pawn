#### [<< главная](../Main.md)
## Глобальные переменные

Глобальные переменные объявляются таким же образом как и локальные:
```pawn
new global_var[uint64];
```
Но такие не требуют инициализации, так что использование <code>uint64zero</code> не обязательно.

### Массив
Объявляется так же, как и локальный массив uint64:
```pawn
new global_arr[10][uint64];
```
Здесь действуют те же [замечания](./2\)%20Local%20variables.md#важное-замечание), что и для локальных переменных, заисключением того, что глобальный массив не требуется инициализировать, он по умолчанию занулён.

### Перечисления (enum)

#### Преамбула

Описание функций является предметом дальнейших пунктов документации, но необходимо рассмотреть хотя бы одну для данного пункта:

```pawn
stock uint64from32(dest[uint64], value)
```
Она устанавливает значение переменной uint64 с помощью обычного 32-битного значения. 

Подробнее об этой функции можно прочитать [тут](./4\)%20Conversions%20from%20other%20data%20types%20and%20vice%20versa.md#преобразование-из-обычного-32-битного-числа).

<hr>

При создании массива с перечислением, поле типа uint64 объявляется так же, как и любого другого типа:
```pawn
enum pInfo
{
    pMoney,
    Float:pX,
    Float:pY,
    Float:pZ,
    // ...

    pBankMoney[uint64] // <-- вот наше поле
}

new PlayerInfo[MAX_PLAYERS][pInfo];
```

Но тут есть один нюанс: при обращении к этому полю, оно будет иметь тип массива с неизвестной длиной. Функции, встроенные в библиотеку требуют, чтобы у массива была задана длина.

Вот пример использования поля в коде:
```pawn
    for(new playerid = 0; playerid < MAX_PLAYERS; playerid++)
    {
        uint64from32(PlayerInfo[playerid][pBankMoney], 10000);
    }
    // Ошибка компиляции: error 007: operator cannot be redefined
```

Обходным путем в данном случае является макрос <code>uint64cpy</code>,
который копирует значение из одной переменной в другую. Таким образом, код будет более медленным, но это является самым простым способом.

Идея заключается в том, чтобы скопировать содержимое <code>PlayerInfo[playerid][pBankMoney]</code> во временную локальную переменную, работать уже с ней, а затем скопировать содержимое обратно. Тогда код будет выглядить следующим образом:

```pawn
    for(new playerid = 0; playerid < MAX_PLAYERS; playerid++)
    {
        new bank_money[uint64];
        uint64cpy(bank_money, PlayerInfo[playerid][pBankMoney]);
        // ^^^ перемещаем содержимое во временную переменную.

        uint64from32(bank_money, 10000);
        // ^^^ работаем с временной переменной.

        uint64cpy(PlayerInfo[playerid][pBankMoney], bank_money);
        // ^^^ записываем обратно в нужное поле.
    }
```

#### Оптимизация
В данном случае код **присваивает** новое значение переменной, т.е он не требует считывать ее значение. 

Также, в данном кусочке кода каждому игроку присваевается одинаковое кол-во денег, то есть нет необходимости каждую итерацию присваивать значение с помощью <code>uint64from32</code>.

Тогда будет разумнее и быстрее сделать так:

```pawn
    new bank_money[uint64];
    uint64from32(bank_money, 10000);

    for(new playerid = 0; playerid < MAX_PLAYERS; playerid++)
    {
        uint64cpy(PlayerInfo[playerid][pBankMoney], bank_money);
    }
```

Такой подход к программированию очень благоприятно скажется на производительности кода.