#### [<< главная](../Main.md)
## Арифметические операции
Библиотека поддерживает четыре основные арифметические операции: сложение, вычитание, умножение и деление *(с возвратом остатка)*.

### Сложение
Поддерживается сложение двух 64-битных чисел и сложение 64-битного числа с 32-битным.

#### Сложение двух 64-битных чисел
```pawn
stock uint64add(oper1[uint64], const oper2[uint64])
```
Складывает два числа и записывает результат в <code>oper1[uint64]</code>.

##### Пример использования
```pawn
main()
{
    new number[uint64];
    uint64fromstr(number, "500 000 000 000");

    new number2[uint64];
    uint64fromstr(number, "440 000 000 000");

    // ^^^ создаём переменные и присваиваем значения.

    uint64add(number, number2);
    // ^^^ после этой строчки, в переменной number будет
    // лежать результат сложения, т.е 940 000 000 000
    
    new str[128];
    uint64tostr(str, sizeof(str), number);
    print(str);
    // ^^^ выводим число number на экран
}
```

#### Сложение 64-битного числа с 32-битным
Является более предпочтительным, чем предыдущий вариант, поскольку является более быстрым.

```pawn
stock uint64add32(number[uint64], add32)
```
Складывает два числа и записывает результат в <code>number[uint64]</code>

##### Важное примечание
Отрицательные значения будут трактоваться как положительные, они не убавят число, поскольку число трактуется как беззнаковое. Например, при сложении с *-1*, прибавится *4 294 967 295*.

##### Пример использования
```pawn
main()
{
    new number[uint64];
    uint64fromstr(number, "500 000 000 000");

    new number2;
    number2 = 500000;

    // ^^^ создаём переменные и присваиваем значения.

    uint64add32(number, number2);
    // ^^^ после этой строчки, в переменной number будет
    // лежать результат сложения, т.е 500 000 500 000
    
    new str[128];
    uint64tostr(str, sizeof(str), number);
    print(str);
    // ^^^ выводим число number на экран
}
```

### Вычитание
Также как и со сложением, поддерживается вычитание для двух 64-битных чисел и вычитание 32-битного числа из 64-битного.

#### Вычитание для двух 64-битных чисел
```pawn
stock uint64sub(oper1[uint64], oper2[uint64])
```
Вычитает второе число из первого, результат записывает в <code>oper1[uint64]</code>.

##### Пример использования
```pawn
main()
{
    new number[uint64];
    uint64fromstr(number, "500 000 000 000");

    new number2[uint64];
    uint64fromstr(number, "440 000 000 000");

    // ^^^ создаём переменные и присваиваем значения.

    uint64sub(number, number2);
    // ^^^ после этой строчки, в переменной number будет
    // лежать результат вычитания, т.е 60 000 000 000
    
    new str[128];
    uint64tostr(str, sizeof(str), number);
    print(str);
    // ^^^ выводим число number на экран
}
```

#### Вычитание 32-битного числа из 64-битного
```pawn
stock uint64sub32(oper1[uint64], oper2)
```
Вычитает 32-битное число <code>oper2</code> из числа <code>oper1[uint64]</code> и записывает в <code>oper1[uint64]</code>.

##### Важное примечание
Отрицательные значения будут трактоваться как положительные, они не увеличат число, поскольку число трактуется как беззнаковое. Например, при вычитании числа *-1*, отнимется *4 294 967 295*.

##### Пример использования
```pawn
main()
{
    new number[uint64];
    uint64fromstr(number, "500 000 000 000");

    new number2;
    number2 = 500000;

    // ^^^ создаём переменные и присваиваем значения.

    uint64sub32(number, number2);
    // ^^^ после этой строчки, в переменной number будет
    // лежать результат вычитания, т.е 499 999 500 000.
    
    new str[128];
    uint64tostr(str, sizeof(str), number);
    print(str);
    // ^^^ выводим число number на экран
}
```

### Умножение и деление

Для операций умножения и деления также предусмотрены функции в библиотеке, однако вторым аргументом в них является 16-битное число. Это было сделано для многократного увеличения производительности.

#### Пределы аргументов операций

Максимальное значение беззнакового 16-битного числа: **65 535**, т.е. это и есть максимально возможный делитель или множитель.

#### Умножение
```pawn
stock uint64mul16(number[uint64], mult16)
```
Эта функция умножает число <code>number[uint64]</code> на 16-битное беззнаковое число <code>mult16</code>.

##### Важные замечания
1) Если значение mult16 не укладывается в 16-бит, то функция обрежет его до 16-бит.
2) Поскольку множитель трактуется как число беззнаковое, то функция неправильно будет работать с отрицательными множителями.
2) 16-битное беззнаковое число передается в функцию так же, как и обычное число.

##### Пример использования
```pawn
main()
{
    new number[uint64];
    uint64fromstr(number, "500 000 000 000");

    // ^^^ создаём переменные и присваиваем значения.

    uint64mul16(number, 20345);
    // ^^^ после этой строчки, в переменной number будет
    // лежать результат умножения, т.е 10 172 500 000 000 000.
    
    new str[128];
    uint64tostr(str, sizeof(str), number);
    print(str);
    // ^^^ выводим число number на экран
}
```

#### Деление
```pawn
stock uint64div16(number[uint64], div16)
```
Эта функция делит число <code>number[uint64]</code> на 16-битное беззнаковое число <code>div16</code>.

##### Возвращаемое значение
Функция возвращает остаток от деления <code>number[uint64]</code> на число <code>div16</code>

##### Важные замечания
1) Если значение div16 не укладывается в 16-бит, то функция обрежет его до 16-бит.
2) Поскольку делитель трактуется как число беззнаковое, то функция неправильно будет работать с отрицательными делителями.
2) 16-битное беззнаковое число передается в функцию так же, как и обычное число.

##### Пример использования
```pawn
main()
{
    new number[uint64];
    uint64fromstr(number, "500 000 000 000");

    // ^^^ создаём переменные и присваиваем значения.

    new remainder;
    remainder = uint64div16(number, 20345);
    // ^^^ после этой строчки, в переменной number будет
    // лежать результат деления, т.е 24 576 062.
    
    // ^^^ в то же время, в переменной remainder
    // будет записан остаток от этого деления
    
    new str[128];
    uint64tostr(str, sizeof(str), number);
    print(str);
    // ^^^ выводим число number на экран
}
```